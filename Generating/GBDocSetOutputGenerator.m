//
//  GBDocSetOutputGenerator.m
//  appledoc
//
//  Created by Tomaz Kragelj on 29.11.10.
//  Copyright 2010 Gentle Bytes. All rights reserved.
//

#import "GRMustache.h"
#import "GBApplicationSettingsProvider.h"
#import "GBDataObjects.h"
#import "GBTemplateHandler.h"
#import "GBDocSetOutputGenerator.h"

@interface GBDocSetOutputGenerator ()

- (BOOL)moveSourceFilesToDocuments:(NSError **)error;
- (BOOL)processInfoPlist:(NSError **)error;
- (BOOL)processNodesXml:(NSError **)error;
- (BOOL)processTokensXml:(NSError **)error;
- (BOOL)processTokensXmlForObjects:(NSArray *)objects type:(NSString *)type template:(NSString *)template index:(NSUInteger *)index error:(NSError **)error;
- (void)initializeSimplifiedObjects;
- (NSArray *)simplifiedObjectsFromObjects:(NSArray *)objects value:(NSString *)value index:(NSUInteger *)index;
- (NSString *)tokenIdentifierForObject:(GBModelBase *)object;
- (NSString *)replacePlaceholdersInString:(NSString *)string;
@property (retain) NSArray *classes;
@property (retain) NSArray *categories;
@property (retain) NSArray *protocols;

@end

#pragma mark -

@implementation GBDocSetOutputGenerator

#pragma Generation handling

- (BOOL)generateOutputWithStore:(id<GBStoreProviding>)store error:(NSError **)error {
	NSParameterAssert(self.previousGenerator != nil);
	if (![super generateOutputWithStore:store error:error]) return NO;
	[self initializeSimplifiedObjects];
	if (![self moveSourceFilesToDocuments:error]) return NO;
	if (![self processInfoPlist:error]) return NO;
	if (![self processNodesXml:error]) return NO;
	if (![self processTokensXml:error]) return NO;
	return YES;
}

- (BOOL)moveSourceFilesToDocuments:(NSError **)error {
	GBLogInfo(@"Moving HTML files to DocSet bundle...");
	
	// Prepare all paths. Note that we determine the exact subdirectory by searching for documents-template and using it's subdirectory as the guide. If documents template wasn't found, exit.
	NSString *sourceFilesPath = [self.previousGenerator.outputUserPath stringByStandardizingPath];
	NSString *documentsPath = [self templateFileKeyEndingWith:@"documents-template"];
	if (!documentsPath) {
		if (error) *error = [NSError errorWithCode:1 description:@"Documents template is missing!" reason:@"documents-template file is required to determine location for Documents path in DocSet bundle!"];
		GBLogWarn(@"Failed finding documents-template in '%@'!", self.templateUserPath);
		return NO;
	}
	
	// First step is to move all files generated by previous generator as the Documents subfolder of docset structure.
	documentsPath = [documentsPath stringByDeletingLastPathComponent];
	NSString *destPath = [self.outputUserPath stringByAppendingPathComponent:documentsPath];
	NSString *movePath = [destPath stringByAppendingPathComponent:@"Documents"];
	if (![self.fileManager moveItemAtPath:sourceFilesPath toPath:[movePath stringByStandardizingPath] error:error]) {
		GBLogWarn(@"Failed moving files from '%@' to '%@'!", self.previousGenerator.outputUserPath, movePath);
		return NO;
	}
	return YES;
}

- (BOOL)processInfoPlist:(NSError **)error {
	GBLogInfo(@"Writting DocSet Info.plist...");
	NSString *templatePath = [self templateFileKeyEndingWith:@"info-template.plist"];
	if (!templatePath) {
		if (error) *error = [NSError errorWithCode:2 description:@"Info.plist template is missing!" reason:@"info-template.plist file is required to specify information about DocSet!"];
		GBLogWarn(@"Failed finding info-template.plist in '%@'!", self.templateUserPath);
		return NO;
	}
	
	// Prepare template variables and replace all placeholders with actual values.
	NSMutableDictionary *vars = [NSMutableDictionary dictionaryWithCapacity:20];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetBundleIdentifier] forKey:@"bundleIdentifier"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetBundleName] forKey:@"bundleName"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetCertificateIssuer] forKey:@"certificateIssuer"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetCertificateSigner] forKey:@"certificateSigner"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetDescription] forKey:@"description"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetFallbackURL] forKey:@"fallbackURL"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetFeedName] forKey:@"feedName"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetFeedURL] forKey:@"feedURL"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetMinimumXcodeVersion] forKey:@"minimumXcodeVersion"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetPlatformFamily] forKey:@"platformFamily"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetPublisherIdentifier] forKey:@"publisherIdentifier"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetPublisherName] forKey:@"publisherName"];
	[vars setObject:[self replacePlaceholdersInString:self.settings.docsetCopyrightMessage] forKey:@"copyrightMessage"];
	
	// Run the template and save the results as Info.plist.
	GBTemplateHandler *handler = [self.templateFiles objectForKey:templatePath];
	NSString *output = [handler renderObject:vars];
	NSString *path = [[templatePath stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"Info.plist"];
	NSString *filename = [self.outputUserPath stringByAppendingPathComponent:path];
	if (![self writeString:output toFile:[filename stringByStandardizingPath] error:error]) {
		GBLogWarn(@"Failed writting Info.plist to '%@'!", filename);
		return NO;
	}
	return YES;
}

- (BOOL)processNodesXml:(NSError **)error {
	GBLogInfo(@"Writting DocSet Nodex.xml file...");
	NSString *templatePath = [self templateFileKeyEndingWith:@"nodes-template.xml"];
	if (!templatePath) {
		if (error) *error = [NSError errorWithCode:2 description:@"Nodes.xml template is missing!" reason:@"nodes-template.xml file is required to specify document structure for DocSet!"];
		GBLogWarn(@"Failed finding nodes-template.xml in '%@'!", self.templateUserPath);
		return NO;
	}
	
	// Prepare the variables for the template.
	NSMutableDictionary *vars = [NSMutableDictionary dictionary];
	[vars setObject:self.settings.projectName forKey:@"projectName"];
	[vars setObject:@"index.html" forKey:@"indexFilename"];
	[vars setObject:([self.classes count] > 0) ? [GRYes yes] : [GRNo no] forKey:@"hasClasses"];
	[vars setObject:([self.categories count] > 0) ? [GRYes yes] : [GRNo no] forKey:@"hasCategories"];
	[vars setObject:([self.protocols count] > 0) ? [GRYes yes] : [GRNo no] forKey:@"hasProtocols"];
	[vars setObject:self.classes forKey:@"classes"];
	[vars setObject:self.categories forKey:@"categories"];
	[vars setObject:self.protocols forKey:@"protocols"];
	[vars setObject:self.settings.stringTemplates forKey:@"strings"];
	
	// Run the template and save the results.
	GBTemplateHandler *handler = [self.templateFiles objectForKey:templatePath];
	NSString *output = [handler renderObject:vars];
	NSString *path = [[templatePath stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"Nodes.xml"];
	NSString *filename = [self.outputUserPath stringByAppendingPathComponent:path];
	if (![self writeString:output toFile:[filename stringByStandardizingPath] error:error]) {
		GBLogWarn(@"Failed writting Nodes.xml to '%@'!", filename);
		return NO;
	}
	return YES;
}

- (BOOL)processTokensXml:(NSError **)error {
	GBLogInfo(@"Writting DocSet Tokens.xml files...");
	
	// Get the template and prepare single Tokens.xml file for each object.
	NSString *templatePath = [self templateFileKeyEndingWith:@"tokens-template.xml"];
	if (!templatePath) {
		GBLogWarn(@"Didn't find tokens-template.xml in '%@', DocSet will not be indexed!", self.templateUserPath);
		return YES;
	}

	// Write each object as a separate token file.
	NSUInteger index = 1;
	if (![self processTokensXmlForObjects:self.classes type:@"cl" template:templatePath index:&index error:error]) return NO;
	if (![self processTokensXmlForObjects:self.categories type:@"cat" template:templatePath index:&index error:error]) return NO;
	if (![self processTokensXmlForObjects:self.protocols type:@"intf" template:templatePath index:&index error:error]) return NO;
	return YES;
}

- (BOOL)processTokensXmlForObjects:(NSArray *)objects type:(NSString *)type template:(NSString *)template index:(NSUInteger *)index error:(NSError **)error {
	// Prepare the output path and template handler then generate file for each object.
	GBTemplateHandler *handler = [self.templateFiles objectForKey:template];
	NSString *outputPath = [template stringByDeletingLastPathComponent];
	NSUInteger idx = *index;
	for (NSMutableDictionary *simplifiedObjectData in objects) {
		// Get the object's methods provider and prepare the array of all methods.
		GBModelBase *topLevelObject = [simplifiedObjectData objectForKey:@"object"];
		GBMethodsProvider *methodsProvider = [topLevelObject valueForKey:@"methods"];

		// Prepare template variables for object. Note that we reuse the ID assigned while creating the data for Nodes.xml.
		NSMutableDictionary *objectData = [NSMutableDictionary dictionaryWithCapacity:2];
		[objectData setObject:[self tokenIdentifierForObject:topLevelObject] forKey:@"identifier"];
		[objectData setObject:[simplifiedObjectData objectForKey:@"id"] forKey:@"refid"];
		[objectData setObject:[[topLevelObject.sourceInfosSortedByName objectAtIndex:0] filename] forKey:@"declaredin"];
		if (topLevelObject.comment && topLevelObject.comment.hasParagraphs) [objectData setObject:topLevelObject.comment.firstParagraph forKey:@"abstract"];

		// Prepare the list of all members.
		NSMutableArray *membersData = [NSMutableArray arrayWithCapacity:[methodsProvider.methods count]];
		for (GBMethodData *method in methodsProvider.methods) {
			NSMutableDictionary *data = [NSMutableDictionary dictionaryWithCapacity:4];
			[data setObject:[self tokenIdentifierForObject:method] forKey:@"identifier"];
			[data setObject:[self.settings htmlReferenceNameForObject:method] forKey:@"anchor"];
			[data setObject:[[method.sourceInfosSortedByName objectAtIndex:0] filename] forKey:@"declaredin"];
			if (method.comment && method.comment.hasParagraphs) [data setObject:method.comment.firstParagraph forKey:@"abstract"];
			[membersData addObject:data];
		}
				
		// Prepare the variables for the template.
		NSMutableDictionary *vars = [NSMutableDictionary dictionary];
		[vars setObject:objectData forKey:@"object"];
		[vars setObject:membersData forKey:@"members"];
		
		// Run the template and save the results.
		NSString *output = [handler renderObject:vars];
		NSString *indexName = [NSString stringWithFormat:@"Tokens%ld.xml", idx++];
		NSString *subpath = [outputPath stringByAppendingPathComponent:indexName];
		NSString *filename = [self.outputUserPath stringByAppendingPathComponent:subpath];
		if (![self writeString:output toFile:[filename stringByStandardizingPath] error:error]) {
			GBLogWarn(@"Failed writting tokens file '%@'!", filename);
			*index = idx;
			return NO;
		}
	}
	*index = idx;
	return YES;
}

#pragma mark Helper methods

- (void)initializeSimplifiedObjects {
	// Prepare flat list of objects for library nodes.
	GBLogDebug(@"Initializing simplified object representations...");
	NSUInteger index = 1;
	self.classes = [self simplifiedObjectsFromObjects:[self.store classesSortedByName] value:@"nameOfClass" index:&index];
	self.categories = [self simplifiedObjectsFromObjects:[self.store categoriesSortedByName] value:@"idOfCategory" index:&index];
	self.protocols = [self simplifiedObjectsFromObjects:[self.store protocolsSortedByName] value:@"nameOfProtocol" index:&index];
}

- (NSArray *)simplifiedObjectsFromObjects:(NSArray *)objects value:(NSString *)value index:(NSUInteger *)index {
	NSUInteger idx = *index;
	NSMutableArray *result = [NSMutableArray arrayWithCapacity:[objects count]];
	for (id object in objects) {
		GBLogDebug(@"Initializing simplified representation of %@ with id %ld...", object, idx);
		NSMutableDictionary *data = [NSMutableDictionary dictionaryWithCapacity:4];
		[data setObject:object forKey:@"object"];
		[data setObject:[NSString stringWithFormat:@"%ld", idx++] forKey:@"id"];
		[data setObject:[object valueForKey:value] forKey:@"name"];
		[data setObject:[self.settings htmlReferenceForObjectFromIndex:object] forKey:@"path"];
		[result addObject:data];
	}
	*index = idx;
	return result;
}

- (NSString *)tokenIdentifierForObject:(GBModelBase *)object {
	if (object.isTopLevelObject) {
		// Class, category and protocol have different prefix, but are straighforward. Note that category has it's class name specified for object name!
		if ([object isKindOfClass:[GBClassData class]]) {
			NSString *objectName = [(GBClassData *)object nameOfClass];
			return [NSString stringWithFormat:@"//apple_ref/occ/cl/%@", objectName];
		} else if ([object isKindOfClass:[GBCategoryData class]]) {
			NSString *objectName = [(GBCategoryData *)object nameOfClass];
			return [NSString stringWithFormat:@"//apple_ref/occ/cat/%@", objectName];
		} else {
			NSString *objectName = [(GBProtocolData *)object nameOfProtocol];
			return [NSString stringWithFormat:@"//apple_ref/occ/intf/%@", objectName];
		}
	} else {
		// Members are slighly more complex - their identifier is different regarding to whether they are part of class or category/protocol. Then it depends on whether they are method or property. Finally their parent object (class/category/protocol) name (again class name for category) and selector should be added.
		if (!object.parentObject) [NSException raise:@"Can't create token identifier for %@; object is not top level and has no parent assigned!", object];
		
		// First handle parent related stuff.
		GBModelBase *parent = object.parentObject;
		NSString *objectName = nil;
		NSString *objectID = nil;
		if ([parent isKindOfClass:[GBClassData class]]) {
			objectName = [(GBClassData *)parent nameOfClass];
			objectID = @"inst";
		} else if ([parent isKindOfClass:[GBCategoryData class]]) {
			objectName = [(GBCategoryData *)parent nameOfClass];
			objectID = @"intf";
		} else {
			objectName = [(GBProtocolData *)parent nameOfProtocol];
			objectID = @"intf";
		}

		// Prepare the actual identifier based on method type.
		GBMethodData *method = (GBMethodData *)object;
		if (method.methodType == GBMethodTypeProperty)
			return [NSString stringWithFormat:@"//apple_ref/occ/%@p/%@/%@", objectID, objectName, method.methodSelector];
		else
			return [NSString stringWithFormat:@"//apple_ref/occ/%@m/%@/%@", objectID, objectName, method.methodSelector];
	}
	return nil;
}

- (NSString *)replacePlaceholdersInString:(NSString *)string {
	string = [string stringByReplacingOccurrencesOfString:@"$PROJECT" withString:self.settings.projectName];
	string = [string stringByReplacingOccurrencesOfString:@"$COMPANY" withString:self.settings.projectCompany];
	string = [string stringByReplacingOccurrencesOfString:@"$YEAR" withString:[self.settings yearStringFromDate:[NSDate date]]];
	string = [string stringByReplacingOccurrencesOfString:@"$UPDATEDATE" withString:[self.settings yearToDayStringFromDate:[NSDate date]]];
	return string;
}

#pragma mark Overriden methods

- (NSString *)outputSubpath {
	return @"docset";
}

#pragma mark Properties

@synthesize classes;
@synthesize categories;
@synthesize protocols;

@end
